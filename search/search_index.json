{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction MIOM (Mixed Integer Optimization for Metabolism) is a python library for creating and solving complex optimization problems using genome-scale metabolic networks, in just a few lines. By leveraging the power of modern Mixed Integer Optimization (MIO) solvers, it can transform any simple constraint-based problem, such as Flux Balance Analysis (FBA) into a more complex optimization problem, such as sparse FBA or context-specific reconstruction problems very easily, and solve it with the required level of optimality . But what is even better is that most of the time, algorithms formulated as Mixed Integer Optimization problems with MIOM can be solved faster and with better quality than currently existing alternatives that are approximations of the original problem. By using the MIO formulation, you can get also an estimation of how close to optimality a solution is, so you don't need to waste more time than needed. MIOM uses the PICOS and the Python-MIP libraries to build and solve the optimization problems using many commercial, academic and free solvers. Warning This library is functional but still in a very early stage. API is still not stable and might be changed in future versions. Installation By default, MIOM comes with support for COIN-OR CBC solver and GLPK using the swiglpk wrapper. To install MIOM with minimal dependencies, run: pip install miom You can also install it with the following command to include the interfaces for Gurobi and Mosek (note that you need a valid license for the solvers): pip install miom[all] CPLEX is also supported, but requires a license. To install MIOM with CPLEX support, follow the instructions on the CPLEX page . A quick example Here is an example of how to load a metabolic network and maximize the flux through a target reaction using FBA, and then how to modify the original problem to implement the sparse FBA problem adding only a few lines to the original problem: from miom import miom , load_gem , Solvers # Load a genome-scale metabolic network using the miom format. # You can load SMBL or Matlab metabolic networks as well using # the same method, but it requires to have the cobratoolbox python library # installed (and scipy for mat files). To install these dependencies, run: # $ pip install cobra scipy network = load_gem ( \"https://github.com/pablormier/miom-gems/raw/main/gems/mus_musculus_iMM1865.miom\" ) target_rxn = \"BIOMASS_reaction\" # Create the optimization problem with miom and solve model = ( miom ( network ) . steady_state () . set_rxn_objective ( target_rxn ) . solve ( verbosity = 1 )) print ( \"Optimal flux:\" , model . get_fluxes ( target_rxn ), \"mmol/(h\u00b7gDW)\" ) # Show reactions with non-zero flux V , _ = model . get_values () print ( \"Number of reactions with non-zero flux:\" , sum ( abs ( V ) > 1e-8 )) Optimal flux: 798.8110517749975 mmol/(h\u00b7gDW) Number of active reactions: 2549 Now, modify the original problem to solve the sparse FBA problem, minimizing the number of reactions with non-zero flux that can lead to the optimal possible flux through the target reaction. This can be easily done by transforming the FBA problem into a subset selection problem, where each reaction has a negative weight and the goal is to remove as many negative weighted reactions as possible. Note that since each reaction has the same weight (-1), all reactions are equally important in the optimization problem: Note To better understand the meaning of each step, please read the documentation of the BaseModel class, and the complete example in examples/sparse_fba.py . V , X = ( model # Set the MIP Gap tolerance to 5%, using the default solver # (COIN-OR CBC included with the Python-MIP lib) . setup ( opt_tol = 0.05 , verbosity = 1 ) # Set the fluxes to the optimal value found . set_fluxes_for ( 'BIOMASS_reaction' ) # Transform to a subset selection problem # adding a negative weight to all reactions # (to remove them from the final solution) . subset_selection ( - 1 ) # Solve the MIO problem . solve () # Get continuos vars (fluxes) and binary vars . get_values ()) # Show reactions with non-zero flux print ( \"Number of active reactions (with non-zero flux):\" , sum ( abs ( V ) > 1e-8 )) Number of active reactions (with non-zero flux): 404 Solving this problem with default COIN-OR CBC solver returns a solution with 404 active reactions (much less than the 2549 reactions obtained with FBA, and less than the 433 reactions returned by the CappedL1 approximation in the sparse FBA implementation in Matlab), with a relative gap between the lower and upper objective bound below 5% (as indicated in the setup method): Cbc0011I Exiting as integer gap of 122.04538 less than 1e-10 or 5% Cbc0001I Search completed - best objective -10208, took 0 iterations and 0 nodes (28.34 seconds) Cbc0035I Maximum depth 0, 0 variables fixed on reduced cost Total time (CPU seconds): 60.79 (Wallclock seconds): 60.79 The concise API provided by MIOM makes everything explicit: the sparse FBA problem can be implemented as a best subset selection problem of reactions (minimize the number of reactions with non-zero flux) subject to the steady-state constraint and the optimality constraint of the flux for the target reaction (in this case the BIOMASS_reaction ). Using this formulation, you can take advantage of modern solvers like CPLEX, GUROBI, MOSEK, COIN-OR CBC (among others) to obtain an optimal or an approximate solution, controlled by the opt_tol parameter. To use other solvers, you only need to provide the specific solver to the miom method, for example: model = ( miom ( network , solver = Solvers . GLPK ) . steady_state () . set_rxn_objective ( target_rxn ) . solve ( verbosity = 1 )) Advantages It's easy to use: MIOM uses the PICOS and the Python-MIP libraries, which means you can use any solver supported by those libraries. It's easy to extend: MIOM is written in pure python, so you can easily extend it to solve more complex optimization problems. It makes the problem explicit: MIOM uses a declarative way to express the problem, so you can easily read and understand what you are solving and differences between algorithms. It's fast: MIOM leverages the power of MIO solvers to solve complex optimization problems. You can control the quality and speed of the solutions for your problem and get better solutions that the approximations (LP) of the original problem available in other constraint-based modeling libraries. It's lightweight: The library has a small number of dependencies, so it's easy to install and distribute also in HPC environments. It includes a compressed GEM format : MIOM can load and save the minimal information of the metabolic networks required for performing simulations into a compressed file compatible with numpy. The small size of the files allows you to quickly run online experiments so other people can reproduce your results. It also supports SBML and matlab formats if cobratoolbox is installed. It's open-source: MIOM is open-source and free to use. You can contribute to the development of MIOM by forking the repository and sending pull requests. How to cite Manuscript in progress License GNU General Public License v3.0","title":"Introduction"},{"location":"#introduction","text":"MIOM (Mixed Integer Optimization for Metabolism) is a python library for creating and solving complex optimization problems using genome-scale metabolic networks, in just a few lines. By leveraging the power of modern Mixed Integer Optimization (MIO) solvers, it can transform any simple constraint-based problem, such as Flux Balance Analysis (FBA) into a more complex optimization problem, such as sparse FBA or context-specific reconstruction problems very easily, and solve it with the required level of optimality . But what is even better is that most of the time, algorithms formulated as Mixed Integer Optimization problems with MIOM can be solved faster and with better quality than currently existing alternatives that are approximations of the original problem. By using the MIO formulation, you can get also an estimation of how close to optimality a solution is, so you don't need to waste more time than needed. MIOM uses the PICOS and the Python-MIP libraries to build and solve the optimization problems using many commercial, academic and free solvers. Warning This library is functional but still in a very early stage. API is still not stable and might be changed in future versions.","title":"Introduction"},{"location":"#installation","text":"By default, MIOM comes with support for COIN-OR CBC solver and GLPK using the swiglpk wrapper. To install MIOM with minimal dependencies, run: pip install miom You can also install it with the following command to include the interfaces for Gurobi and Mosek (note that you need a valid license for the solvers): pip install miom[all] CPLEX is also supported, but requires a license. To install MIOM with CPLEX support, follow the instructions on the CPLEX page .","title":"Installation"},{"location":"#a-quick-example","text":"Here is an example of how to load a metabolic network and maximize the flux through a target reaction using FBA, and then how to modify the original problem to implement the sparse FBA problem adding only a few lines to the original problem: from miom import miom , load_gem , Solvers # Load a genome-scale metabolic network using the miom format. # You can load SMBL or Matlab metabolic networks as well using # the same method, but it requires to have the cobratoolbox python library # installed (and scipy for mat files). To install these dependencies, run: # $ pip install cobra scipy network = load_gem ( \"https://github.com/pablormier/miom-gems/raw/main/gems/mus_musculus_iMM1865.miom\" ) target_rxn = \"BIOMASS_reaction\" # Create the optimization problem with miom and solve model = ( miom ( network ) . steady_state () . set_rxn_objective ( target_rxn ) . solve ( verbosity = 1 )) print ( \"Optimal flux:\" , model . get_fluxes ( target_rxn ), \"mmol/(h\u00b7gDW)\" ) # Show reactions with non-zero flux V , _ = model . get_values () print ( \"Number of reactions with non-zero flux:\" , sum ( abs ( V ) > 1e-8 )) Optimal flux: 798.8110517749975 mmol/(h\u00b7gDW) Number of active reactions: 2549 Now, modify the original problem to solve the sparse FBA problem, minimizing the number of reactions with non-zero flux that can lead to the optimal possible flux through the target reaction. This can be easily done by transforming the FBA problem into a subset selection problem, where each reaction has a negative weight and the goal is to remove as many negative weighted reactions as possible. Note that since each reaction has the same weight (-1), all reactions are equally important in the optimization problem: Note To better understand the meaning of each step, please read the documentation of the BaseModel class, and the complete example in examples/sparse_fba.py . V , X = ( model # Set the MIP Gap tolerance to 5%, using the default solver # (COIN-OR CBC included with the Python-MIP lib) . setup ( opt_tol = 0.05 , verbosity = 1 ) # Set the fluxes to the optimal value found . set_fluxes_for ( 'BIOMASS_reaction' ) # Transform to a subset selection problem # adding a negative weight to all reactions # (to remove them from the final solution) . subset_selection ( - 1 ) # Solve the MIO problem . solve () # Get continuos vars (fluxes) and binary vars . get_values ()) # Show reactions with non-zero flux print ( \"Number of active reactions (with non-zero flux):\" , sum ( abs ( V ) > 1e-8 )) Number of active reactions (with non-zero flux): 404 Solving this problem with default COIN-OR CBC solver returns a solution with 404 active reactions (much less than the 2549 reactions obtained with FBA, and less than the 433 reactions returned by the CappedL1 approximation in the sparse FBA implementation in Matlab), with a relative gap between the lower and upper objective bound below 5% (as indicated in the setup method): Cbc0011I Exiting as integer gap of 122.04538 less than 1e-10 or 5% Cbc0001I Search completed - best objective -10208, took 0 iterations and 0 nodes (28.34 seconds) Cbc0035I Maximum depth 0, 0 variables fixed on reduced cost Total time (CPU seconds): 60.79 (Wallclock seconds): 60.79 The concise API provided by MIOM makes everything explicit: the sparse FBA problem can be implemented as a best subset selection problem of reactions (minimize the number of reactions with non-zero flux) subject to the steady-state constraint and the optimality constraint of the flux for the target reaction (in this case the BIOMASS_reaction ). Using this formulation, you can take advantage of modern solvers like CPLEX, GUROBI, MOSEK, COIN-OR CBC (among others) to obtain an optimal or an approximate solution, controlled by the opt_tol parameter. To use other solvers, you only need to provide the specific solver to the miom method, for example: model = ( miom ( network , solver = Solvers . GLPK ) . steady_state () . set_rxn_objective ( target_rxn ) . solve ( verbosity = 1 ))","title":"A quick example"},{"location":"#advantages","text":"It's easy to use: MIOM uses the PICOS and the Python-MIP libraries, which means you can use any solver supported by those libraries. It's easy to extend: MIOM is written in pure python, so you can easily extend it to solve more complex optimization problems. It makes the problem explicit: MIOM uses a declarative way to express the problem, so you can easily read and understand what you are solving and differences between algorithms. It's fast: MIOM leverages the power of MIO solvers to solve complex optimization problems. You can control the quality and speed of the solutions for your problem and get better solutions that the approximations (LP) of the original problem available in other constraint-based modeling libraries. It's lightweight: The library has a small number of dependencies, so it's easy to install and distribute also in HPC environments. It includes a compressed GEM format : MIOM can load and save the minimal information of the metabolic networks required for performing simulations into a compressed file compatible with numpy. The small size of the files allows you to quickly run online experiments so other people can reproduce your results. It also supports SBML and matlab formats if cobratoolbox is installed. It's open-source: MIOM is open-source and free to use. You can contribute to the development of MIOM by forking the repository and sending pull requests.","title":"Advantages"},{"location":"#how-to-cite","text":"Manuscript in progress","title":"How to cite"},{"location":"#license","text":"GNU General Public License v3.0","title":"License"},{"location":"examples/fastcore/","text":"Exact Fastcore (MIP) Example of implementation of the Fastcore algorithm with MIOM to extract a context specific model. Fastcore defines a set of core reactions that is forced to be active (carry a non-zero flux in steady state conditions), and minimizes the set of non-core reactions. Cite Vlassis, Pacheco, Sauter (2014). Fast reconstruction of compact context-specific metbolic network models. PLoS Comput. Biol. 10, e1003424 . The Fastcore algorithm is greedy approximation of the exact problem which can be modelled as a MIP problem. With MIOM, the exact problem can be defined in a few lines, using the opt_tol parameter to control the level of optimality required: from miom import miom , Solvers from miom.mio import load_gem from miom.miom import Comparator , ExtractionMode import numpy as np # Use the flux-consistent subnetwork (fcm) of the Human1 GEM model m = load_gem ( 'https://github.com/pablormier/miom-gems/raw/main/gems/homo_sapiens_human1_fcm.miom' ) # Select reactions from the cholesterol metabolism as the core reactions to keep core_rxn = m . find_reactions_from_pathway ( \"Cholesterol metabolism\" ) print ( sum ( core_rxn )) # Assign a negative weight for reactions not in the core weights = - 1 * np . ones ( m . num_reactions ) weights [ core_rxn == 1 ] = 1 # Exact-Fastcore fmc = ( miom ( m , solver = Solvers . GUROBI_PYMIP ) . setup ( opt_tol = 0.01 ) . steady_state () . subset_selection ( weights ) . keep ( np . where ( core_rxn == 1 )[ 0 ]) . solve ( verbosity = 1 ) . select_subnetwork ( mode = ExtractionMode . ABSOLUTE_FLUX_VALUE , comparator = Comparator . GREATER_OR_EQUAL , value = 1e-8 ) . network ) print ( fmc . num_reactions ) Note that the algorithm requires that the metabolic network used is flux consistent. If blocked reactions are included in the core set, the MIP becomes infeasible, as those reactions cannot be selected with a non-zero flux in steady state conditions. MIOM includes an implementation of the swiftcore algorithm to obtain flux consistent metabolic networks.","title":"Exact Fastcore (MIP)"},{"location":"examples/fastcore/#exact-fastcore-mip","text":"Example of implementation of the Fastcore algorithm with MIOM to extract a context specific model. Fastcore defines a set of core reactions that is forced to be active (carry a non-zero flux in steady state conditions), and minimizes the set of non-core reactions. Cite Vlassis, Pacheco, Sauter (2014). Fast reconstruction of compact context-specific metbolic network models. PLoS Comput. Biol. 10, e1003424 . The Fastcore algorithm is greedy approximation of the exact problem which can be modelled as a MIP problem. With MIOM, the exact problem can be defined in a few lines, using the opt_tol parameter to control the level of optimality required: from miom import miom , Solvers from miom.mio import load_gem from miom.miom import Comparator , ExtractionMode import numpy as np # Use the flux-consistent subnetwork (fcm) of the Human1 GEM model m = load_gem ( 'https://github.com/pablormier/miom-gems/raw/main/gems/homo_sapiens_human1_fcm.miom' ) # Select reactions from the cholesterol metabolism as the core reactions to keep core_rxn = m . find_reactions_from_pathway ( \"Cholesterol metabolism\" ) print ( sum ( core_rxn )) # Assign a negative weight for reactions not in the core weights = - 1 * np . ones ( m . num_reactions ) weights [ core_rxn == 1 ] = 1 # Exact-Fastcore fmc = ( miom ( m , solver = Solvers . GUROBI_PYMIP ) . setup ( opt_tol = 0.01 ) . steady_state () . subset_selection ( weights ) . keep ( np . where ( core_rxn == 1 )[ 0 ]) . solve ( verbosity = 1 ) . select_subnetwork ( mode = ExtractionMode . ABSOLUTE_FLUX_VALUE , comparator = Comparator . GREATER_OR_EQUAL , value = 1e-8 ) . network ) print ( fmc . num_reactions ) Note that the algorithm requires that the metabolic network used is flux consistent. If blocked reactions are included in the core set, the MIP becomes infeasible, as those reactions cannot be selected with a non-zero flux in steady state conditions. MIOM includes an implementation of the swiftcore algorithm to obtain flux consistent metabolic networks.","title":"Exact Fastcore (MIP)"},{"location":"examples/fba/","text":"Flux Balance Analysis (LP) A simple Flux Balance Analysis can be easily defined and solved with any of the commercial or open-source solvers available: from miom import miom , load_gem network = load_gem ( \"https://github.com/pablormier/miom-gems/raw/main/gems/mus_musculus_iMM1865.miom\" ) target = \"BIOMASS_reaction\" flux = ( miom ( network ) . steady_state () . set_rxn_objective ( target ) . solve ( verbosity = 1 ) . get_fluxes ( target )) print ( \"Optimal flux is\" , flux )","title":"Flux Balance Analysis (LP)"},{"location":"examples/fba/#flux-balance-analysis-lp","text":"A simple Flux Balance Analysis can be easily defined and solved with any of the commercial or open-source solvers available: from miom import miom , load_gem network = load_gem ( \"https://github.com/pablormier/miom-gems/raw/main/gems/mus_musculus_iMM1865.miom\" ) target = \"BIOMASS_reaction\" flux = ( miom ( network ) . steady_state () . set_rxn_objective ( target ) . solve ( verbosity = 1 ) . get_fluxes ( target )) print ( \"Optimal flux is\" , flux )","title":"Flux Balance Analysis (LP)"},{"location":"examples/imat/","text":"iMAT: Integrative Metabolic Analysis Tool (MIP) Example implementation of iMAT using MIOM. Note that this implementation supports also custom weights for the reactions. By default, weights for reactions in the \"active\" set are set to 1, and reactions in the \"inactive\" set are set to -1, so the objective function is exactly the same as the original iMAT. Cite Shlomi, T., Cabili, M. N., Herrg\u00e5rd, M. J., Palsson, B. \u00d8., & Ruppin, E. (2008). Network-based prediction of human tissue-specific metabolism. Nature biotechnology, 26(9), 1003-1010 . from miom import miom , Solvers from miom.mio import load_gem from miom.miom import Comparator , ExtractionMode # Use the iHuman-GEM model m = load_gem ( 'https://github.com/pablormier/miom-gems/raw/main/gems/homo_sapiens_human1.miom' ) # Add all the reactions from the Cholesterol pathway to the highly expressed set RH = m . find_reactions_from_pathway ( \"Cholesterol metabolism\" ) # Add reactions from the pyruvate metabolism to the lowly expressed set RL = - 1 * m . find_reactions_from_pathway ( \"Pyruvate metabolism\" ) w = RH + RL print ( \"RH:\" , sum ( RH ), \"RL:\" , sum ( abs ( RL ))) m = ( miom ( m , solver = Solvers . GUROBI ) . setup ( int_tol = 1e-8 , opt_tol = 0.01 , verbosity = 1 ) . steady_state () . subset_selection ( w ) . solve ( max_seconds = 30 ) . select_subnetwork ( mode = ExtractionMode . ABSOLUTE_FLUX_VALUE , comparator = Comparator . GREATER_OR_EQUAL , value = 1e-8 ) . network ) print ( m . num_reactions )","title":"iMAT: Integrative Metabolic Analysis Tool (MIP)"},{"location":"examples/imat/#imat-integrative-metabolic-analysis-tool-mip","text":"Example implementation of iMAT using MIOM. Note that this implementation supports also custom weights for the reactions. By default, weights for reactions in the \"active\" set are set to 1, and reactions in the \"inactive\" set are set to -1, so the objective function is exactly the same as the original iMAT. Cite Shlomi, T., Cabili, M. N., Herrg\u00e5rd, M. J., Palsson, B. \u00d8., & Ruppin, E. (2008). Network-based prediction of human tissue-specific metabolism. Nature biotechnology, 26(9), 1003-1010 . from miom import miom , Solvers from miom.mio import load_gem from miom.miom import Comparator , ExtractionMode # Use the iHuman-GEM model m = load_gem ( 'https://github.com/pablormier/miom-gems/raw/main/gems/homo_sapiens_human1.miom' ) # Add all the reactions from the Cholesterol pathway to the highly expressed set RH = m . find_reactions_from_pathway ( \"Cholesterol metabolism\" ) # Add reactions from the pyruvate metabolism to the lowly expressed set RL = - 1 * m . find_reactions_from_pathway ( \"Pyruvate metabolism\" ) w = RH + RL print ( \"RH:\" , sum ( RH ), \"RL:\" , sum ( abs ( RL ))) m = ( miom ( m , solver = Solvers . GUROBI ) . setup ( int_tol = 1e-8 , opt_tol = 0.01 , verbosity = 1 ) . steady_state () . subset_selection ( w ) . solve ( max_seconds = 30 ) . select_subnetwork ( mode = ExtractionMode . ABSOLUTE_FLUX_VALUE , comparator = Comparator . GREATER_OR_EQUAL , value = 1e-8 ) . network ) print ( m . num_reactions )","title":"iMAT: Integrative Metabolic Analysis Tool (MIP)"},{"location":"examples/sparse_fba/","text":"Sparse FBA (MIP) The sparse FBA problem consists of finding the optimal flux value for a reaction minimizing the number of reactions with non-zero flux (l0-norm sparsity). Note that minimizing the l0-norm is a NP-hard problem, and so obtaing an optimal solution is not possible in many cases. The COBRA Toolbox includes different LP heuristics to minimize different approximations of the l0-norm. However, using a MIO formulation, it's is possible to obtain a solution which is close to optimal, with a lower number of reactions than the LP approximations, and very quickly. Here is the implementation of sparse-FBA with MIOM: from miom import miom , load_gem , Solvers # Load a genome-scale metabolic network. You can load SMBL or Matlab metabolic networks # as well using the same method, but it requires to have the cobratoolbox python library # installed. network = load_gem ( \"https://github.com/pablormier/miom-gems/raw/main/gems/mus_musculus_iMM1865.miom\" ) # Create the sparse FBA problem to get a solution that maximizes # the optimal flux through the BIOMASS_reaction minimizing the # number of active reactions. The solution should be not more than # 5% of the optimal solution (opt_tol = 0.05). V , X = ( miom ( network , solver = Solvers . GUROBI_PYMIP ) # Set-up the solver options . setup ( int_tol = 1e-8 , opt_tol = 0.05 , verbosity = 1 ) # Add the steady-state constraints (S*V = 0) . steady_state () # Set the reaction to optimize using FBA . set_rxn_objective ( 'BIOMASS_reaction' ) # Solve the FBA (LP) problem (optimal flux) . solve () # Add a constraint to force a flux through # the reaction equal to the optimal flux . set_fluxes_for ( 'BIOMASS_reaction' ) # Convert to a MIO problem (best subset selection) # Each reaction in the network is associated # with a negative weight of -1. The optimization # problem now tries to minimize the selection of # reactions with negative weights (respecting # the previous constraints). Since each reaction # has a weight of -1, all reactions are equally # important in the optimization problem. # This is exactly the optimal sparse-FBA problem # with l0-norm: minimize the number of reactions # but mantaining the optimal FBA flux possible. . subset_selection ( - 1 ) # Solve the MIO problem (note that it's NP-Hard) # You can control the optimality by changing the # opt_tol in the .setup() method. . solve () # Return the flux values (V) and the binary # indicator values (X) . get_values ()) # Show reactions with a flux > 1e-7 print ( \"Number of reactions with flux above +/- 1e-7:\" , sum ( abs ( V ) > 1e-7 )) # Count reactions with an indicator value of 0 (active). Note that since # the weights of the reactions are negative (for all rxns), an indicator # value of 1 corresponds to a succesful removed reaction not included in # the solution, and a value of 0 to a reaction that could not be removed. print ( \"Indicator variables with a value of 1 (selected rxns):\" , sum ( X < 0.5 )) # Show the flux value of the biomass reaction print ( \"Optimal biomass flux:\" , V [ m . get_reaction_id ( \"BIOMASS_reaction\" )], \"mmol/(h\u00b7gDW)\" )","title":"Sparse FBA (MIP)"},{"location":"examples/sparse_fba/#sparse-fba-mip","text":"The sparse FBA problem consists of finding the optimal flux value for a reaction minimizing the number of reactions with non-zero flux (l0-norm sparsity). Note that minimizing the l0-norm is a NP-hard problem, and so obtaing an optimal solution is not possible in many cases. The COBRA Toolbox includes different LP heuristics to minimize different approximations of the l0-norm. However, using a MIO formulation, it's is possible to obtain a solution which is close to optimal, with a lower number of reactions than the LP approximations, and very quickly. Here is the implementation of sparse-FBA with MIOM: from miom import miom , load_gem , Solvers # Load a genome-scale metabolic network. You can load SMBL or Matlab metabolic networks # as well using the same method, but it requires to have the cobratoolbox python library # installed. network = load_gem ( \"https://github.com/pablormier/miom-gems/raw/main/gems/mus_musculus_iMM1865.miom\" ) # Create the sparse FBA problem to get a solution that maximizes # the optimal flux through the BIOMASS_reaction minimizing the # number of active reactions. The solution should be not more than # 5% of the optimal solution (opt_tol = 0.05). V , X = ( miom ( network , solver = Solvers . GUROBI_PYMIP ) # Set-up the solver options . setup ( int_tol = 1e-8 , opt_tol = 0.05 , verbosity = 1 ) # Add the steady-state constraints (S*V = 0) . steady_state () # Set the reaction to optimize using FBA . set_rxn_objective ( 'BIOMASS_reaction' ) # Solve the FBA (LP) problem (optimal flux) . solve () # Add a constraint to force a flux through # the reaction equal to the optimal flux . set_fluxes_for ( 'BIOMASS_reaction' ) # Convert to a MIO problem (best subset selection) # Each reaction in the network is associated # with a negative weight of -1. The optimization # problem now tries to minimize the selection of # reactions with negative weights (respecting # the previous constraints). Since each reaction # has a weight of -1, all reactions are equally # important in the optimization problem. # This is exactly the optimal sparse-FBA problem # with l0-norm: minimize the number of reactions # but mantaining the optimal FBA flux possible. . subset_selection ( - 1 ) # Solve the MIO problem (note that it's NP-Hard) # You can control the optimality by changing the # opt_tol in the .setup() method. . solve () # Return the flux values (V) and the binary # indicator values (X) . get_values ()) # Show reactions with a flux > 1e-7 print ( \"Number of reactions with flux above +/- 1e-7:\" , sum ( abs ( V ) > 1e-7 )) # Count reactions with an indicator value of 0 (active). Note that since # the weights of the reactions are negative (for all rxns), an indicator # value of 1 corresponds to a succesful removed reaction not included in # the solution, and a value of 0 to a reaction that could not be removed. print ( \"Indicator variables with a value of 1 (selected rxns):\" , sum ( X < 0.5 )) # Show the flux value of the biomass reaction print ( \"Optimal biomass flux:\" , V [ m . get_reaction_id ( \"BIOMASS_reaction\" )], \"mmol/(h\u00b7gDW)\" )","title":"Sparse FBA (MIP)"},{"location":"references/mio/","text":"mio.py MiomNetwork A minimal class to store a metabolic network. Attributes: Name Type Description S numpy.ndarray stoichiometric matrix R numpy.ndarray Structured array with the reactions. The fields are: - id (int): reaction ID - lb (float): lower bound - ub (float): upper bound - subsystem (str): subsystem - gpr (str): gene-protein-reaction rule M numpy.ndarray Structured array with the metabolites. The fields are: - id (int): metabolite ID - name (str): metabolite name - formula (str): metabolite formula num_reactions property readonly Number of reactions in the network. Returns: Type Description int Number of reactions find_reaction ( self , rxn_id ) Find a particular reaction in the metabolic network. Parameters: Name Type Description Default rxn_id str Name of the reaction required Returns: Type Description numpy.ndarray Structured array with the information of the reaction. Source code in miom/mio.py def find_reaction ( self , rxn_id ): \"\"\"Find a particular reaction in the metabolic network. Args: rxn_id (str): Name of the reaction Returns: numpy.ndarray: Structured array with the information of the reaction. \"\"\" return MiomNetwork . _find_reaction ( rxn_id , self . R ) export_gem ( miom_network , path_to_exported_file ) Export a miom network to a file in the miom format. Parameters: Name Type Description Default miom_network MiomNetwork an instance of a MiomNetwork required path_to_exported_file str Path to the exported file (e.g. /path/to/file.miom) required Source code in miom/mio.py def export_gem ( miom_network , path_to_exported_file ): \"\"\"Export a miom network to a file in the miom format. Args: miom_network (MiomNetwork): an instance of a MiomNetwork path_to_exported_file (str): Path to the exported file (e.g. /path/to/file.miom) \"\"\" import lzma with io . BytesIO () as npz : np . savez_compressed ( npz , S = miom_network . S , reactions = miom_network . R , metabolites = miom_network . M ) compressed = lzma . compress ( npz . getbuffer ()) # Store to file with open ( path_to_exported_file , 'wb' ) as f_out : f_out . write ( compressed ) load_gem ( model_or_path ) Load a metabolic network from a file or URL. The method supports any format supported by cobrapy (.xml, .yml, .json, .mat) or a miom compressed model (.miom) from a url or a local file path. For the cobra supported formats, you need the cobrapy package installed, and for .mat files, you need both cobrapy and scipy installed. Parameters: Name Type Description Default model_or_path str Path to a local file or URL pointing to the metabolic network required Returns: Type Description MiomNetwork A MiomNetwork instance with the minimal information of the metabolic network required for simulations. It includes the stoichiometric matrix, the list of reactions with the lower and upper bounds, the associated genes and GPR rules, and the list of metabolites. Source code in miom/mio.py def load_gem ( model_or_path ): \"\"\"Load a metabolic network from a file or URL. The method supports any format supported by cobrapy (.xml, .yml, .json, .mat) or a miom compressed model (.miom) from a url or a local file path. For the cobra supported formats, you need the cobrapy package installed, and for .mat files, you need both cobrapy and scipy installed. Args: model_or_path (str): Path to a local file or URL pointing to the metabolic network Returns: MiomNetwork: A [MiomNetwork][miom.mio] instance with the minimal information of the metabolic network required for simulations. It includes the stoichiometric matrix, the list of reactions with the lower and upper bounds, the associated genes and GPR rules, and the list of metabolites. \"\"\" if isinstance ( model_or_path , str ): file = model_or_path if _is_url ( model_or_path ): file = _download ( model_or_path ) ext = pathlib . Path ( file ) . suffix if ext == '.miom' or ext == '.xz' or ext == '.npz' : return _load_compressed_model ( file ) else : return _cobra_to_miom ( _read_cobra_model ( file )) else : return _cobra_to_miom ( model_or_path )","title":"mio.py"},{"location":"references/mio/#miopy","text":"","title":"mio.py"},{"location":"references/mio/#miom.mio.MiomNetwork","text":"A minimal class to store a metabolic network. Attributes: Name Type Description S numpy.ndarray stoichiometric matrix R numpy.ndarray Structured array with the reactions. The fields are: - id (int): reaction ID - lb (float): lower bound - ub (float): upper bound - subsystem (str): subsystem - gpr (str): gene-protein-reaction rule M numpy.ndarray Structured array with the metabolites. The fields are: - id (int): metabolite ID - name (str): metabolite name - formula (str): metabolite formula","title":"MiomNetwork"},{"location":"references/mio/#miom.mio.MiomNetwork.num_reactions","text":"Number of reactions in the network. Returns: Type Description int Number of reactions","title":"num_reactions"},{"location":"references/mio/#miom.mio.MiomNetwork.find_reaction","text":"Find a particular reaction in the metabolic network. Parameters: Name Type Description Default rxn_id str Name of the reaction required Returns: Type Description numpy.ndarray Structured array with the information of the reaction. Source code in miom/mio.py def find_reaction ( self , rxn_id ): \"\"\"Find a particular reaction in the metabolic network. Args: rxn_id (str): Name of the reaction Returns: numpy.ndarray: Structured array with the information of the reaction. \"\"\" return MiomNetwork . _find_reaction ( rxn_id , self . R )","title":"find_reaction()"},{"location":"references/mio/#miom.mio.export_gem","text":"Export a miom network to a file in the miom format. Parameters: Name Type Description Default miom_network MiomNetwork an instance of a MiomNetwork required path_to_exported_file str Path to the exported file (e.g. /path/to/file.miom) required Source code in miom/mio.py def export_gem ( miom_network , path_to_exported_file ): \"\"\"Export a miom network to a file in the miom format. Args: miom_network (MiomNetwork): an instance of a MiomNetwork path_to_exported_file (str): Path to the exported file (e.g. /path/to/file.miom) \"\"\" import lzma with io . BytesIO () as npz : np . savez_compressed ( npz , S = miom_network . S , reactions = miom_network . R , metabolites = miom_network . M ) compressed = lzma . compress ( npz . getbuffer ()) # Store to file with open ( path_to_exported_file , 'wb' ) as f_out : f_out . write ( compressed )","title":"export_gem()"},{"location":"references/mio/#miom.mio.load_gem","text":"Load a metabolic network from a file or URL. The method supports any format supported by cobrapy (.xml, .yml, .json, .mat) or a miom compressed model (.miom) from a url or a local file path. For the cobra supported formats, you need the cobrapy package installed, and for .mat files, you need both cobrapy and scipy installed. Parameters: Name Type Description Default model_or_path str Path to a local file or URL pointing to the metabolic network required Returns: Type Description MiomNetwork A MiomNetwork instance with the minimal information of the metabolic network required for simulations. It includes the stoichiometric matrix, the list of reactions with the lower and upper bounds, the associated genes and GPR rules, and the list of metabolites. Source code in miom/mio.py def load_gem ( model_or_path ): \"\"\"Load a metabolic network from a file or URL. The method supports any format supported by cobrapy (.xml, .yml, .json, .mat) or a miom compressed model (.miom) from a url or a local file path. For the cobra supported formats, you need the cobrapy package installed, and for .mat files, you need both cobrapy and scipy installed. Args: model_or_path (str): Path to a local file or URL pointing to the metabolic network Returns: MiomNetwork: A [MiomNetwork][miom.mio] instance with the minimal information of the metabolic network required for simulations. It includes the stoichiometric matrix, the list of reactions with the lower and upper bounds, the associated genes and GPR rules, and the list of metabolites. \"\"\" if isinstance ( model_or_path , str ): file = model_or_path if _is_url ( model_or_path ): file = _download ( model_or_path ) ext = pathlib . Path ( file ) . suffix if ext == '.miom' or ext == '.xz' or ext == '.npz' : return _load_compressed_model ( file ) else : return _cobra_to_miom ( _read_cobra_model ( file )) else : return _cobra_to_miom ( model_or_path )","title":"load_gem()"},{"location":"references/miom/","text":"miom.py BaseModel Base class for building LP/MIP metabolic models using a high-level API for metabolic problems. It implements the chainable methods to set-up a LP/MIP metabolic network problem. Two implementations are available: PicosModel and PythonMipModel. The PicosModel uses the PICOS library as a backend to interact with different solvers. The PythonMipModel uses the Python-MIP library to solve the model using the CBC or GUROBI solvers. Note Do not try to instantiate this class directly. Use the miom() function instead. The method automatically selects the right implementation depending on the solver. add_constraints ( self , constraints ) Add a list of constraint to the model Parameters: Name Type Description Default constraints list List of expressions with the constraints. required Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def add_constraints ( self , constraints ): \"\"\"Add a list of constraint to the model Args: constraints (list): List of expressions with the constraints. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" for c in constraints : self . add_constraint ( c ) return len ( constraints ) > 0 get_fluxes ( self , reactions = None ) Get the flux values. Parameters: Name Type Description Default reactions list Reaction or subset of reactions For which to obtain the flux values. Defaults to None. None Returns: Type Description list List with the flux values for all or the selected reactions. Source code in miom/miom.py def get_fluxes ( self , reactions = None ): \"\"\"Get the flux values. Args: reactions (list, optional): Reaction or subset of reactions For which to obtain the flux values. Defaults to None. Returns: list: List with the flux values for all or the selected reactions. \"\"\" if isinstance ( reactions , str ): return self . variables . flux_values [ self . network . get_reaction_id ( reactions )] if isinstance ( reactions , Iterable ): return { r [ 'id' ]: self . variables . flux_values [ self . network . get_reaction_id ( r [ 'id' ])] for r in reactions } if reactions is None : return self . variables . flux_values else : raise ValueError ( \"reactions should be an iterable of strings or a single string\" ) get_values ( self ) Get the values for the variables Returns: Type Description tuple (V, X) where V are the flux values and X are the indicator values (if the problem is a MIP problem, for example if subset_selection was called) Source code in miom/miom.py def get_values ( self ): \"\"\"Get the values for the variables Returns: tuple: (V, X) where V are the flux values and X are the indicator values (if the problem is a MIP problem, for example if `subset_selection` was called) \"\"\" return self . variables . values () keep ( self , reactions ) Force the inclusion of a list of reactions in the solution. Reactions have to be associated with positive weights in order to keep them in the final solution. Parameters: Name Type Description Default reactions list List of reaction names, a binary vector indicating the reactions to keep, or a list of indexes with the reactions to keep. required Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def keep ( self , reactions ): \"\"\"Force the inclusion of a list of reactions in the solution. Reactions have to be associated with positive weights in order to keep them in the final solution. Args: reactions (list): List of reaction names, a binary vector indicating the reactions to keep, or a list of indexes with the reactions to keep. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" if self . variables . indicators is None : raise ValueError ( \"No indicator variables for reactions, \" \"transform it to a subset selection problem calling \" \"subset_selection first, providing positive weights for the \" \"reactions you want to keep.\" ) if reactions is None or len ( reactions ) == 0 : return False if isinstance ( reactions , str ): reactions = [ reactions ] # Check if the reactions have an indicator variable reactions = set ( self . network . find_reaction ( rxn )[ 0 ] for rxn in reactions ) available = set ( rxn . index for rxn in self . variables . assigned_reactions if rxn . cost > 0 ) diff = reactions - available if len ( diff ) != 0 : raise ValueError ( f \"Only reactions associated with positive weights \" f \"can be forced to be selected. The following reaction \" f \"indexes have no indicator variables or are associated with \" f \"negative weights: { diff } .\" ) valid_rxn_idx = reactions & available # Get the indexes of the indicator variables idxs = [ i for i , r in enumerate ( self . variables . assigned_reactions ) if r . index in valid_rxn_idx ] return dict ( idxs = idxs , valid_rxn_idx = valid_rxn_idx ) obtain_subnetwork ( self , extraction_mode =< ExtractionMode . ABSOLUTE_FLUX_VALUE : 'flux_value' > , comparator =< Comparator . GREATER_OR_EQUAL : 'geq' > , value = 1e-06 ) Same as select_subnetwork but returns the network instead. See select_subnetwork for a detailed description of the method. Returns: Type Description MiomNetwork A MiomNetwork with the selected subnetwork. Source code in miom/miom.py def obtain_subnetwork ( self , extraction_mode = ExtractionMode . ABSOLUTE_FLUX_VALUE , comparator = Comparator . GREATER_OR_EQUAL , value = 1e-6 ): \"\"\"Same as [select_subnetwork][miom.miom.BaseModel] but returns the network instead. See [select_subnetwork][miom.miom.BaseModel] for a detailed description of the method. Returns: MiomNetwork: A MiomNetwork with the selected subnetwork. \"\"\" # If indicators are present and assigned, # take the subset of the network for which # the indicators of positive weighted reactions # are equal to 1 if extraction_mode == ExtractionMode . ABSOLUTE_FLUX_VALUE : variables = self . variables . flux_values if variables is None : raise ValueError ( \"The model does not contain flux variables. \" \"You need to call first steady_state() to add \" \"the flux variables\" ) elif extraction_mode == ExtractionMode . INDICATOR_VALUE : variables = self . variables . indicator_values if variables is None : raise ValueError ( \"The model does not contain indicator variables. \" \"You need to transform it to a subset selection problem \" \"by invoking subset_selection() first.\" ) else : raise ValueError ( \"Invalid extraction mode\" ) if comparator == Comparator . GREATER_OR_EQUAL : selected = np . where ( np . abs ( variables ) >= value )[ 0 ] elif comparator == Comparator . LESS_OR_EQUAL : selected = np . where ( np . abs ( variables ) <= value )[ 0 ] else : raise ValueError ( \"Invalid comparison\" ) # TODO: Assigned reactions work only for indicator variables if extraction_mode == ExtractionMode . INDICATOR_VALUE : rxns = [ self . variables . assigned_reactions [ x ] for x in selected ] selected_idx = [ rxn . index for rxn in rxns ] else : selected_idx = selected S_sub = self . network . S [:, selected_idx ] R_sub = self . network . R [ selected_idx ] act_met = np . sum ( np . abs ( S_sub ), axis = 1 ) > 0 M_sub = self . network . M [ act_met ] S_sub = S_sub [ act_met , :] return MiomNetwork ( S_sub , R_sub , M_sub ) reset ( self ) Resets the original problem (removes all modifications) Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def reset ( self ): \"\"\"Resets the original problem (removes all modifications) Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" if self . problem is None : warnings . warn ( \"Problem is not initialized, nothing to reset\" ) return False else : return True select_subnetwork ( self , mode =< ExtractionMode . ABSOLUTE_FLUX_VALUE : 'flux_value' > , comparator =< Comparator . GREATER_OR_EQUAL : 'geq' > , value = 1e-08 ) Select a subnetwork and create a new BaseModel to operate on it. The new instance of the BaseModel is a new problem instance with no constraints. If the idea is to perform FBA simulations on this new subnetwork, remember to add the new constraints, especially the steady_state . Parameters: Name Type Description Default mode ExtractionMode Method used to extract the subnetwork (based on flux values or using the indicator values). Defaults to ExtractionMode.ABSOLUTE_FLUX_VALUE. <ExtractionMode.ABSOLUTE_FLUX_VALUE: 'flux_value'> comparator Comparator Comparator for the selected mode. Defaults to Comparator.GREATER_OR_EQUAL. <Comparator.GREATER_OR_EQUAL: 'geq'> value float Value threshold for the mode and comparator selected. Defaults to 1e-8. 1e-08 Returns: Type Description [type] [description] Source code in miom/miom.py @_autochain def select_subnetwork ( self , mode = ExtractionMode . ABSOLUTE_FLUX_VALUE , comparator = Comparator . GREATER_OR_EQUAL , value = 1e-8 ): \"\"\"Select a subnetwork and create a new BaseModel to operate on it. The new instance of the BaseModel is a new problem instance with no constraints. If the idea is to perform FBA simulations on this new subnetwork, remember to add the new constraints, especially the `steady_state`. Args: mode (ExtractionMode, optional): Method used to extract the subnetwork (based on flux values or using the indicator values). Defaults to ExtractionMode.ABSOLUTE_FLUX_VALUE. comparator (Comparator, optional): Comparator for the selected mode. Defaults to Comparator.GREATER_OR_EQUAL. value (float, optional): Value threshold for the mode and comparator selected. Defaults to 1e-8. Returns: [type]: [description] \"\"\" return self . obtain_subnetwork ( extraction_mode = mode , comparator = comparator , value = value ) set_flux_bounds ( self , rxn_id , min_flux = None , max_flux = None ) Change the flux bounds of a reaction. Parameters: Name Type Description Default rxn_id str/int name or id of the reaction to change required min_flux float Min flux value. Defaults to None. None max_flux float Max flux value. Defaults to None. None Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def set_flux_bounds ( self , rxn_id , min_flux = None , max_flux = None ): \"\"\"Change the flux bounds of a reaction. Args: rxn_id (str/int): name or id of the reaction to change min_flux (float, optional): Min flux value. Defaults to None. max_flux (float, optional): Max flux value. Defaults to None. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" i , _ = self . network . find_reaction ( rxn_id ) return i set_fluxes_for ( self , reactions , tolerance = 1e-06 ) Force the flux of certain reactions to match current values. After calling .solve() for a flux optimization problem (e.g. FBA), this method adds a new constraint to force the flux of the given reactions to match the current flux values found after the optimization. This is interesting for example to implement methods like sparse-FBA, where the optimization is no longer the flux but the number of active reactions, and a new constraint is required to preserve optimality of fluxes. Parameters: Name Type Description Default reactions list reaction or list of reactions required tolerance float Tolerance for the flux values (a solution is valid if the flux is within optimal value +/- tol. Defaults to 1e-6. 1e-06 Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py def set_fluxes_for ( self , reactions , tolerance = 1e-6 ): \"\"\"Force the flux of certain reactions to match current values. After calling `.solve()` for a flux optimization problem (e.g. FBA), this method adds a new constraint to force the flux of the given reactions to match the current flux values found after the optimization. This is interesting for example to implement methods like sparse-FBA, where the optimization is no longer the flux but the number of active reactions, and a new constraint is required to preserve optimality of fluxes. Args: reactions (list): reaction or list of reactions tolerance (float, optional): Tolerance for the flux values (a solution is valid if the flux is within optimal value +/- tol. Defaults to 1e-6. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" i , r = self . network . find_reaction ( reactions ) lb = max ( r [ 'lb' ], self . variables . flux_values [ i ] - tolerance ) ub = min ( r [ 'ub' ], self . variables . flux_values [ i ] + tolerance ) self . add_constraint ( self . variables . fluxes [ i ] >= lb ) self . add_constraint ( self . variables . fluxes [ i ] <= ub ) return self set_objective ( self , cost_vector , variables , direction = 'max' ) Set the optmization objective of the model. Parameters: Name Type Description Default cost_vector Iterable List with the cost for each variable required variables Iterable Variables used for the objective function required direction str Optimization direction (min or max). Defaults to 'max'. 'max' Source code in miom/miom.py @_autochain def set_objective ( self , cost_vector , variables , direction = 'max' ): \"\"\"Set the optmization objective of the model. Args: cost_vector (Iterable): List with the cost for each variable variables (Iterable): Variables used for the objective function direction (str, optional): Optimization direction (min or max). Defaults to 'max'. \"\"\" if self . objective is not None : warnings . warn ( \"Previous objective changed\" ) self . objective = ( cost_vector , variables , direction ) set_rxn_objective ( self , rxn , direction = 'max' ) Set a flux objective Maximize or minimize the flux through a given reaction. Parameters: Name Type Description Default rxn str Name of the reaction to use for the optimization required direction str Minimization or maximization of the flux ('min' or 'max'). Defaults to 'max'. 'max' Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py def set_rxn_objective ( self , rxn , direction = 'max' ): \"\"\"Set a flux objective Maximize or minimize the flux through a given reaction. Args: rxn (str): Name of the reaction to use for the optimization direction (str, optional): Minimization or maximization of the flux ('min' or 'max'). Defaults to 'max'. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" i , _ = self . network . find_reaction ( rxn ) cost = np . zeros (( 1 , self . network . R . shape [ 0 ])) cost [ 0 , i ] = 1 self . set_objective ( cost , self . variables . fluxes , direction = direction ) return self setup ( self , ** kwargs ) Provide the options for the solver. Attributes: Name Type Description int_tol float Integrality tolerance for integer variables. Defaults to 1e-8. feas_tol float Feasibility tolerance. Defaults to 1e-8. opt_tol float Relative MIP gap tolerance for MIP problems. Defaults to 1e-5. verbosity int Values above 0 force the backends to be verbose. Use a value of 1 to show useful information about the search. Defaults to 0. Returns: Type Description BaseModel the configured instance of the BaseModel Source code in miom/miom.py @_autochain def setup ( self , ** kwargs ): \"\"\"Provide the options for the solver. Attributes: int_tol (float): Integrality tolerance for integer variables. Defaults to 1e-8. feas_tol (float): Feasibility tolerance. Defaults to 1e-8. opt_tol (float): Relative MIP gap tolerance for MIP problems. Defaults to 1e-5. verbosity (int): Values above 0 force the backends to be verbose. Use a value of 1 to show useful information about the search. Defaults to 0. Returns: BaseModel: the configured instance of the BaseModel \"\"\" if self . problem is None : warnings . warn ( \"Problem cannot be configured since it was not initialized\" ) return False options = dict () int_tol = kwargs [ \"int_tol\" ] if \"int_tol\" in kwargs else None feas_tol = kwargs [ \"feas_tol\" ] if \"feas_tol\" in kwargs else None opt_tol = kwargs [ \"opt_tol\" ] if \"opt_tol\" in kwargs else None verbosity = kwargs [ \"verbosity\" ] if \"verbosity\" in kwargs else None solver = kwargs [ \"solver\" ] if \"solver\" in kwargs else None if int_tol is not None : options [ \"int_tol\" ] = int_tol if feas_tol is not None : options [ \"feas_tol\" ] = feas_tol if opt_tol is not None : options [ \"opt_tol\" ] = opt_tol if verbosity is not None : options [ \"verbosity\" ] = verbosity if solver is not None : options [ \"solver\" ] = solver self . _options . update ( options ) # Calculate a min eps value to avoid numerical issues self . _options [ \"_min_eps\" ] = np . sqrt ( 2 * self . _options [ \"int_tol\" ]) return self . _options steady_state ( self ) Add the required constraints for finding steady-state fluxes The method adds the \\(S * V = 0\\) set of constraints, where \\(S\\) is the stoichiometric matrix and \\(V\\) the flux variables. Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def steady_state ( self ): \"\"\"Add the required constraints for finding steady-state fluxes The method adds the $S * V = 0$ set of constraints, where $S$ is the stoichiometric matrix and $V$ the flux variables. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" pass subset_selection ( self , rxn_weights , eps = 0.01 ) Transform the current model into a subset selection problem. The subset selection problem consists of selecting the positive weighted reactions and remove the negative weighted reactions, subject to steady state constraints and/or additional constraints on fluxes, and maximizing the weighted sum of the (absolute) weights for the successfully selected reactions (with positive weights) and the successfully removed reactions (with negative weights) Each reaction is associated with a weight (positive or negative) provided in the parameter rxn_weights , and the objective is to select the reactions that optimizes the following expression: \\[ f(x) = \\sum_i^n |w_i| * x_i \\] where \\(x_i\\) are the indicator variables for the reactions \\(i\\) and \\(w_i\\) are the weights for the reactions associated to the indicator variable. Indicator variables are automatically created for each reaction associated to a non-zero weight. Two (mutually exclusive) indicator variables are used for positive weighted reactions that are reversible to indicate whether there is positive or negative flux through the reaction. A single indicator variable is created for positive weighted non-reversible reactions, to indicate if the reaction is selected (has a non-zero flux) in which case the indicator variable is 1, or 0 otherwise. A single binary indicator variable is also created for negative weighted reactions, indicating whether the reaction was not selected (i.e, has 0 flux, in which case the indicator variable is 1) or not (in which case the indicator variable is 0). Parameters: Name Type Description Default rxn_weights list List of weights for each reaction. If a single value is provided, it is assumed to be the weight for all reactions. required eps float Min absolute flux value for weighted reactions to consider them active or inactive. Defaults to 1e-2. 0.01 Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def subset_selection ( self , rxn_weights , eps = 1e-2 ): \"\"\"Transform the current model into a subset selection problem. The subset selection problem consists of selecting the positive weighted reactions and remove the negative weighted reactions, subject to steady state constraints and/or additional constraints on fluxes, and maximizing the weighted sum of the (absolute) weights for the successfully selected reactions (with positive weights) and the successfully removed reactions (with negative weights) Each reaction is associated with a weight (positive or negative) provided in the parameter `rxn_weights`, and the objective is to select the reactions that optimizes the following expression: $$ f(x) = \\sum_i^n |w_i| * x_i $$ where $x_i$ are the indicator variables for the reactions $i$ and $w_i$ are the weights for the reactions associated to the indicator variable. Indicator variables are automatically created for each reaction associated to a non-zero weight. Two (mutually exclusive) indicator variables are used for positive weighted reactions that are reversible to indicate whether there is positive or negative flux through the reaction. A single indicator variable is created for positive weighted non-reversible reactions, to indicate if the reaction is selected (has a non-zero flux) in which case the indicator variable is 1, or 0 otherwise. A single binary indicator variable is also created for negative weighted reactions, indicating whether the reaction was not selected (i.e, has 0 flux, in which case the indicator variable is 1) or not (in which case the indicator variable is 0). Args: rxn_weights (list): List of weights for each reaction. If a single value is provided, it is assumed to be the weight for all reactions. eps (float, optional): Min absolute flux value for weighted reactions to consider them active or inactive. Defaults to 1e-2. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" # Calculate min valid EPS based on integrality tolerance min_eps = self . _options [ \"_min_eps\" ] if eps < min_eps : warnings . warn ( f \"The minimum epsilon value is { min_eps } , which is less than { eps } .\" ) eps = max ( eps , min_eps ) if not isinstance ( rxn_weights , Iterable ): rxn_weights = [ rxn_weights ] * self . network . num_reactions rxnw = _weighted_rxns ( self . network . R , rxn_weights ) if self . variables . indicators is None : self . variables . _assigned_reactions = rxnw return dict ( eps = eps ) else : warnings . warn ( \"Indicator variables were already assigned\" ) return False Comparator Comparator enum to use with select_subnetwork() Attributes: Name Type Description GREATER_OR_EQUAL str Select those variables with a value greater or equal than the one provided. LESS_OR_EQUAL str Select those variables with a value less or equal than the one provided. ExtractionMode Method to select the subnetwork to be extracted. This mode works with the method select_subnetwork only after a subset selection problem was succesfully solved. If the model is configured as a subset selection problem, the user can extract a subnetwork after the method solve() was called. The selection of the subnetwork can be done using the indicator variables or the flux variables. For more information, please read the documentation of the method subset_selection Attributes: Name Type Description ABSOLUTE_FLUX_VALUE str Use a decision criterion based on the value of the fluxes. For example, by selecting all the reactions that have an absolute flux value above a certain threshold. INDICATOR_VALUE str Use the binary indicator variables to select the subnetwork. Binary indicator variables are created for a subset selection problem (after calling subset_selection ). Two indicators are created for each positive weighted and reversible reaction, to indicate if there is a non-zero positive flux or negative flux respectively. A single binary indicator variable is created for each negative weighted reaction. In this case, an indicator value of 1 indicates that the reaction was succesfully removed, and 0 otherwise. You can use the value of the indicator variables to select a subnetwork after solving. For example, if all the reactions have a negative weight (since the goal is, for example, to minimize the number of reactions subject to some other constraints) and you want to select only the reactions that were not removed after solving, you can use the indicator variables with a value of 0. Usage example: m . steady_state () . add_constraints ( ... ) . # Convert to a subset selection, where each reaction # has a weight of -1. subset_selection ( - 1 ) . # Solve the optimization problem . solve () # Get the subnetwork selecting the reactions # with an indicator value below 0.5. Since variables # are binary, it basically selects all the reactions # associated with a binary indicator value of 0. # This corresponds to the reactions that were not # removed after solving the problem (since all the # reactions have negative weights, and their binary # indicator variables are 1 if they were successfully # removed, and 0 if they could not be removed). . select_subnetwork ( mode = ExtractionMode . INDICATOR_VALUE , comparator = Comparator . LESS_OR_EQUAL , value = 0.5 ) . network Solvers Solvers supported by the miom module. Please refer to https://picos-api.gitlab.io/picos/introduction.html to see the list of supported solvers using the PICOS backend. The Python-MIP backend only supports the GUROBI and CBC solvers. Note that in some cases, the Python-MIP backend (GUROBI/CBC) might be faster setting up the problem than the PICOS backend since it has less overhead. Attributes: Name Type Description GUROBI_PYMIP str Recommended solver for most problems (LP, MIP). It uses the Python-MIP backend. Note that GUROBI is a commercial software which require a license. Free academic licenses are also available at https://gurobi.com/free/. GUROBI str For using GUROBI with the PICOS backend instead of Python-MIP. COIN_OR_CBC str Free LP/MIP solver with good performance, provided with Python-MIP. CPLEX str Commercial solver with a performance similar to GUROBI. Only supported by the PICOS backend. SCIP str Free academic solver, supported by the PICOS backend. GLPK str Open source solver, supported by the PICOS backend. MOSEK str Commercial solver, supported by the PICOS backend. miom ( network , solver =< Solvers . COIN_OR_CBC : 'cbc' > ) Create a MIOM optimization model for a given solver. If the solver is Coin-OR CBC, an instance of PythonMipModel is used (which uses the Python-MIP lib as the backend). Otherwise, a PicosModel is created (which uses PICOS as the backend). Examples: Example of how to perform FBA to maximize flux through the BIOMASS_reaction in the iMM1865 model: >>> from miom import miom , load_gem >>> network = load_gem ( \"https://github.com/pablormier/miom-gems/raw/main/gems/mus_musculus_iMM1865.miom\" ) >>> V , _ = miom ( network ) . steady_state () . set_rxn_objective ( \"BIOMASS_reaction\" ) . solve ( verbosity = 1 ) . get_values ()) Parameters: Name Type Description Default network miom_network A miom metabolic network. A metabolic network can be imported with the load_gem function. required solver Solver The solver to be used. Defaults to Solver.GLPK. <Solvers.COIN_OR_CBC: 'cbc'> Returns: Type Description BaseModel A BaseModel object, which can be PythonMipModel if CBC solver is used, or a PicosModel otherwise. Source code in miom/miom.py def miom ( network , solver = Solvers . COIN_OR_CBC ): \"\"\" Create a MIOM optimization model for a given solver. If the solver is Coin-OR CBC, an instance of PythonMipModel is used (which uses the Python-MIP lib as the backend). Otherwise, a PicosModel is created (which uses PICOS as the backend). Example: Example of how to perform FBA to maximize flux through the BIOMASS_reaction in the iMM1865 model: ```python >>> from miom import miom, load_gem >>> network = load_gem(\"https://github.com/pablormier/miom-gems/raw/main/gems/mus_musculus_iMM1865.miom\") >>> V, _ = miom(network) .steady_state() .set_rxn_objective(\"BIOMASS_reaction\") .solve(verbosity=1) .get_values()) ``` Args: network (miom_network): A miom metabolic network. A metabolic network can be imported with the [load_gem][miom.mio.load_gem] function. solver (Solver, optional): The solver to be used. Defaults to Solver.GLPK. Returns: BaseModel: A BaseModel object, which can be PythonMipModel if CBC solver is used, or a PicosModel otherwise. \"\"\" solver = str ( solver . value ) if isinstance ( solver , Enum ) else str ( solver ) if solver == 'cbc' : return PythonMipModel ( miom_network = network , solver_name = solver ) if solver == 'gurobi_pymip' : return PythonMipModel ( miom_network = network , solver_name = 'gurobi' ) else : return PicosModel ( miom_network = network , solver_name = solver )","title":"miom.py"},{"location":"references/miom/#miompy","text":"","title":"miom.py"},{"location":"references/miom/#miom.miom.BaseModel","text":"Base class for building LP/MIP metabolic models using a high-level API for metabolic problems. It implements the chainable methods to set-up a LP/MIP metabolic network problem. Two implementations are available: PicosModel and PythonMipModel. The PicosModel uses the PICOS library as a backend to interact with different solvers. The PythonMipModel uses the Python-MIP library to solve the model using the CBC or GUROBI solvers. Note Do not try to instantiate this class directly. Use the miom() function instead. The method automatically selects the right implementation depending on the solver.","title":"BaseModel"},{"location":"references/miom/#miom.miom.BaseModel.add_constraints","text":"Add a list of constraint to the model Parameters: Name Type Description Default constraints list List of expressions with the constraints. required Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def add_constraints ( self , constraints ): \"\"\"Add a list of constraint to the model Args: constraints (list): List of expressions with the constraints. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" for c in constraints : self . add_constraint ( c ) return len ( constraints ) > 0","title":"add_constraints()"},{"location":"references/miom/#miom.miom.BaseModel.get_fluxes","text":"Get the flux values. Parameters: Name Type Description Default reactions list Reaction or subset of reactions For which to obtain the flux values. Defaults to None. None Returns: Type Description list List with the flux values for all or the selected reactions. Source code in miom/miom.py def get_fluxes ( self , reactions = None ): \"\"\"Get the flux values. Args: reactions (list, optional): Reaction or subset of reactions For which to obtain the flux values. Defaults to None. Returns: list: List with the flux values for all or the selected reactions. \"\"\" if isinstance ( reactions , str ): return self . variables . flux_values [ self . network . get_reaction_id ( reactions )] if isinstance ( reactions , Iterable ): return { r [ 'id' ]: self . variables . flux_values [ self . network . get_reaction_id ( r [ 'id' ])] for r in reactions } if reactions is None : return self . variables . flux_values else : raise ValueError ( \"reactions should be an iterable of strings or a single string\" )","title":"get_fluxes()"},{"location":"references/miom/#miom.miom.BaseModel.get_values","text":"Get the values for the variables Returns: Type Description tuple (V, X) where V are the flux values and X are the indicator values (if the problem is a MIP problem, for example if subset_selection was called) Source code in miom/miom.py def get_values ( self ): \"\"\"Get the values for the variables Returns: tuple: (V, X) where V are the flux values and X are the indicator values (if the problem is a MIP problem, for example if `subset_selection` was called) \"\"\" return self . variables . values ()","title":"get_values()"},{"location":"references/miom/#miom.miom.BaseModel.keep","text":"Force the inclusion of a list of reactions in the solution. Reactions have to be associated with positive weights in order to keep them in the final solution. Parameters: Name Type Description Default reactions list List of reaction names, a binary vector indicating the reactions to keep, or a list of indexes with the reactions to keep. required Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def keep ( self , reactions ): \"\"\"Force the inclusion of a list of reactions in the solution. Reactions have to be associated with positive weights in order to keep them in the final solution. Args: reactions (list): List of reaction names, a binary vector indicating the reactions to keep, or a list of indexes with the reactions to keep. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" if self . variables . indicators is None : raise ValueError ( \"No indicator variables for reactions, \" \"transform it to a subset selection problem calling \" \"subset_selection first, providing positive weights for the \" \"reactions you want to keep.\" ) if reactions is None or len ( reactions ) == 0 : return False if isinstance ( reactions , str ): reactions = [ reactions ] # Check if the reactions have an indicator variable reactions = set ( self . network . find_reaction ( rxn )[ 0 ] for rxn in reactions ) available = set ( rxn . index for rxn in self . variables . assigned_reactions if rxn . cost > 0 ) diff = reactions - available if len ( diff ) != 0 : raise ValueError ( f \"Only reactions associated with positive weights \" f \"can be forced to be selected. The following reaction \" f \"indexes have no indicator variables or are associated with \" f \"negative weights: { diff } .\" ) valid_rxn_idx = reactions & available # Get the indexes of the indicator variables idxs = [ i for i , r in enumerate ( self . variables . assigned_reactions ) if r . index in valid_rxn_idx ] return dict ( idxs = idxs , valid_rxn_idx = valid_rxn_idx )","title":"keep()"},{"location":"references/miom/#miom.miom.BaseModel.obtain_subnetwork","text":"Same as select_subnetwork but returns the network instead. See select_subnetwork for a detailed description of the method. Returns: Type Description MiomNetwork A MiomNetwork with the selected subnetwork. Source code in miom/miom.py def obtain_subnetwork ( self , extraction_mode = ExtractionMode . ABSOLUTE_FLUX_VALUE , comparator = Comparator . GREATER_OR_EQUAL , value = 1e-6 ): \"\"\"Same as [select_subnetwork][miom.miom.BaseModel] but returns the network instead. See [select_subnetwork][miom.miom.BaseModel] for a detailed description of the method. Returns: MiomNetwork: A MiomNetwork with the selected subnetwork. \"\"\" # If indicators are present and assigned, # take the subset of the network for which # the indicators of positive weighted reactions # are equal to 1 if extraction_mode == ExtractionMode . ABSOLUTE_FLUX_VALUE : variables = self . variables . flux_values if variables is None : raise ValueError ( \"The model does not contain flux variables. \" \"You need to call first steady_state() to add \" \"the flux variables\" ) elif extraction_mode == ExtractionMode . INDICATOR_VALUE : variables = self . variables . indicator_values if variables is None : raise ValueError ( \"The model does not contain indicator variables. \" \"You need to transform it to a subset selection problem \" \"by invoking subset_selection() first.\" ) else : raise ValueError ( \"Invalid extraction mode\" ) if comparator == Comparator . GREATER_OR_EQUAL : selected = np . where ( np . abs ( variables ) >= value )[ 0 ] elif comparator == Comparator . LESS_OR_EQUAL : selected = np . where ( np . abs ( variables ) <= value )[ 0 ] else : raise ValueError ( \"Invalid comparison\" ) # TODO: Assigned reactions work only for indicator variables if extraction_mode == ExtractionMode . INDICATOR_VALUE : rxns = [ self . variables . assigned_reactions [ x ] for x in selected ] selected_idx = [ rxn . index for rxn in rxns ] else : selected_idx = selected S_sub = self . network . S [:, selected_idx ] R_sub = self . network . R [ selected_idx ] act_met = np . sum ( np . abs ( S_sub ), axis = 1 ) > 0 M_sub = self . network . M [ act_met ] S_sub = S_sub [ act_met , :] return MiomNetwork ( S_sub , R_sub , M_sub )","title":"obtain_subnetwork()"},{"location":"references/miom/#miom.miom.BaseModel.reset","text":"Resets the original problem (removes all modifications) Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def reset ( self ): \"\"\"Resets the original problem (removes all modifications) Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" if self . problem is None : warnings . warn ( \"Problem is not initialized, nothing to reset\" ) return False else : return True","title":"reset()"},{"location":"references/miom/#miom.miom.BaseModel.select_subnetwork","text":"Select a subnetwork and create a new BaseModel to operate on it. The new instance of the BaseModel is a new problem instance with no constraints. If the idea is to perform FBA simulations on this new subnetwork, remember to add the new constraints, especially the steady_state . Parameters: Name Type Description Default mode ExtractionMode Method used to extract the subnetwork (based on flux values or using the indicator values). Defaults to ExtractionMode.ABSOLUTE_FLUX_VALUE. <ExtractionMode.ABSOLUTE_FLUX_VALUE: 'flux_value'> comparator Comparator Comparator for the selected mode. Defaults to Comparator.GREATER_OR_EQUAL. <Comparator.GREATER_OR_EQUAL: 'geq'> value float Value threshold for the mode and comparator selected. Defaults to 1e-8. 1e-08 Returns: Type Description [type] [description] Source code in miom/miom.py @_autochain def select_subnetwork ( self , mode = ExtractionMode . ABSOLUTE_FLUX_VALUE , comparator = Comparator . GREATER_OR_EQUAL , value = 1e-8 ): \"\"\"Select a subnetwork and create a new BaseModel to operate on it. The new instance of the BaseModel is a new problem instance with no constraints. If the idea is to perform FBA simulations on this new subnetwork, remember to add the new constraints, especially the `steady_state`. Args: mode (ExtractionMode, optional): Method used to extract the subnetwork (based on flux values or using the indicator values). Defaults to ExtractionMode.ABSOLUTE_FLUX_VALUE. comparator (Comparator, optional): Comparator for the selected mode. Defaults to Comparator.GREATER_OR_EQUAL. value (float, optional): Value threshold for the mode and comparator selected. Defaults to 1e-8. Returns: [type]: [description] \"\"\" return self . obtain_subnetwork ( extraction_mode = mode , comparator = comparator , value = value )","title":"select_subnetwork()"},{"location":"references/miom/#miom.miom.BaseModel.set_flux_bounds","text":"Change the flux bounds of a reaction. Parameters: Name Type Description Default rxn_id str/int name or id of the reaction to change required min_flux float Min flux value. Defaults to None. None max_flux float Max flux value. Defaults to None. None Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def set_flux_bounds ( self , rxn_id , min_flux = None , max_flux = None ): \"\"\"Change the flux bounds of a reaction. Args: rxn_id (str/int): name or id of the reaction to change min_flux (float, optional): Min flux value. Defaults to None. max_flux (float, optional): Max flux value. Defaults to None. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" i , _ = self . network . find_reaction ( rxn_id ) return i","title":"set_flux_bounds()"},{"location":"references/miom/#miom.miom.BaseModel.set_fluxes_for","text":"Force the flux of certain reactions to match current values. After calling .solve() for a flux optimization problem (e.g. FBA), this method adds a new constraint to force the flux of the given reactions to match the current flux values found after the optimization. This is interesting for example to implement methods like sparse-FBA, where the optimization is no longer the flux but the number of active reactions, and a new constraint is required to preserve optimality of fluxes. Parameters: Name Type Description Default reactions list reaction or list of reactions required tolerance float Tolerance for the flux values (a solution is valid if the flux is within optimal value +/- tol. Defaults to 1e-6. 1e-06 Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py def set_fluxes_for ( self , reactions , tolerance = 1e-6 ): \"\"\"Force the flux of certain reactions to match current values. After calling `.solve()` for a flux optimization problem (e.g. FBA), this method adds a new constraint to force the flux of the given reactions to match the current flux values found after the optimization. This is interesting for example to implement methods like sparse-FBA, where the optimization is no longer the flux but the number of active reactions, and a new constraint is required to preserve optimality of fluxes. Args: reactions (list): reaction or list of reactions tolerance (float, optional): Tolerance for the flux values (a solution is valid if the flux is within optimal value +/- tol. Defaults to 1e-6. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" i , r = self . network . find_reaction ( reactions ) lb = max ( r [ 'lb' ], self . variables . flux_values [ i ] - tolerance ) ub = min ( r [ 'ub' ], self . variables . flux_values [ i ] + tolerance ) self . add_constraint ( self . variables . fluxes [ i ] >= lb ) self . add_constraint ( self . variables . fluxes [ i ] <= ub ) return self","title":"set_fluxes_for()"},{"location":"references/miom/#miom.miom.BaseModel.set_objective","text":"Set the optmization objective of the model. Parameters: Name Type Description Default cost_vector Iterable List with the cost for each variable required variables Iterable Variables used for the objective function required direction str Optimization direction (min or max). Defaults to 'max'. 'max' Source code in miom/miom.py @_autochain def set_objective ( self , cost_vector , variables , direction = 'max' ): \"\"\"Set the optmization objective of the model. Args: cost_vector (Iterable): List with the cost for each variable variables (Iterable): Variables used for the objective function direction (str, optional): Optimization direction (min or max). Defaults to 'max'. \"\"\" if self . objective is not None : warnings . warn ( \"Previous objective changed\" ) self . objective = ( cost_vector , variables , direction )","title":"set_objective()"},{"location":"references/miom/#miom.miom.BaseModel.set_rxn_objective","text":"Set a flux objective Maximize or minimize the flux through a given reaction. Parameters: Name Type Description Default rxn str Name of the reaction to use for the optimization required direction str Minimization or maximization of the flux ('min' or 'max'). Defaults to 'max'. 'max' Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py def set_rxn_objective ( self , rxn , direction = 'max' ): \"\"\"Set a flux objective Maximize or minimize the flux through a given reaction. Args: rxn (str): Name of the reaction to use for the optimization direction (str, optional): Minimization or maximization of the flux ('min' or 'max'). Defaults to 'max'. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" i , _ = self . network . find_reaction ( rxn ) cost = np . zeros (( 1 , self . network . R . shape [ 0 ])) cost [ 0 , i ] = 1 self . set_objective ( cost , self . variables . fluxes , direction = direction ) return self","title":"set_rxn_objective()"},{"location":"references/miom/#miom.miom.BaseModel.setup","text":"Provide the options for the solver. Attributes: Name Type Description int_tol float Integrality tolerance for integer variables. Defaults to 1e-8. feas_tol float Feasibility tolerance. Defaults to 1e-8. opt_tol float Relative MIP gap tolerance for MIP problems. Defaults to 1e-5. verbosity int Values above 0 force the backends to be verbose. Use a value of 1 to show useful information about the search. Defaults to 0. Returns: Type Description BaseModel the configured instance of the BaseModel Source code in miom/miom.py @_autochain def setup ( self , ** kwargs ): \"\"\"Provide the options for the solver. Attributes: int_tol (float): Integrality tolerance for integer variables. Defaults to 1e-8. feas_tol (float): Feasibility tolerance. Defaults to 1e-8. opt_tol (float): Relative MIP gap tolerance for MIP problems. Defaults to 1e-5. verbosity (int): Values above 0 force the backends to be verbose. Use a value of 1 to show useful information about the search. Defaults to 0. Returns: BaseModel: the configured instance of the BaseModel \"\"\" if self . problem is None : warnings . warn ( \"Problem cannot be configured since it was not initialized\" ) return False options = dict () int_tol = kwargs [ \"int_tol\" ] if \"int_tol\" in kwargs else None feas_tol = kwargs [ \"feas_tol\" ] if \"feas_tol\" in kwargs else None opt_tol = kwargs [ \"opt_tol\" ] if \"opt_tol\" in kwargs else None verbosity = kwargs [ \"verbosity\" ] if \"verbosity\" in kwargs else None solver = kwargs [ \"solver\" ] if \"solver\" in kwargs else None if int_tol is not None : options [ \"int_tol\" ] = int_tol if feas_tol is not None : options [ \"feas_tol\" ] = feas_tol if opt_tol is not None : options [ \"opt_tol\" ] = opt_tol if verbosity is not None : options [ \"verbosity\" ] = verbosity if solver is not None : options [ \"solver\" ] = solver self . _options . update ( options ) # Calculate a min eps value to avoid numerical issues self . _options [ \"_min_eps\" ] = np . sqrt ( 2 * self . _options [ \"int_tol\" ]) return self . _options","title":"setup()"},{"location":"references/miom/#miom.miom.BaseModel.steady_state","text":"Add the required constraints for finding steady-state fluxes The method adds the \\(S * V = 0\\) set of constraints, where \\(S\\) is the stoichiometric matrix and \\(V\\) the flux variables. Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def steady_state ( self ): \"\"\"Add the required constraints for finding steady-state fluxes The method adds the $S * V = 0$ set of constraints, where $S$ is the stoichiometric matrix and $V$ the flux variables. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" pass","title":"steady_state()"},{"location":"references/miom/#miom.miom.BaseModel.subset_selection","text":"Transform the current model into a subset selection problem. The subset selection problem consists of selecting the positive weighted reactions and remove the negative weighted reactions, subject to steady state constraints and/or additional constraints on fluxes, and maximizing the weighted sum of the (absolute) weights for the successfully selected reactions (with positive weights) and the successfully removed reactions (with negative weights) Each reaction is associated with a weight (positive or negative) provided in the parameter rxn_weights , and the objective is to select the reactions that optimizes the following expression: \\[ f(x) = \\sum_i^n |w_i| * x_i \\] where \\(x_i\\) are the indicator variables for the reactions \\(i\\) and \\(w_i\\) are the weights for the reactions associated to the indicator variable. Indicator variables are automatically created for each reaction associated to a non-zero weight. Two (mutually exclusive) indicator variables are used for positive weighted reactions that are reversible to indicate whether there is positive or negative flux through the reaction. A single indicator variable is created for positive weighted non-reversible reactions, to indicate if the reaction is selected (has a non-zero flux) in which case the indicator variable is 1, or 0 otherwise. A single binary indicator variable is also created for negative weighted reactions, indicating whether the reaction was not selected (i.e, has 0 flux, in which case the indicator variable is 1) or not (in which case the indicator variable is 0). Parameters: Name Type Description Default rxn_weights list List of weights for each reaction. If a single value is provided, it is assumed to be the weight for all reactions. required eps float Min absolute flux value for weighted reactions to consider them active or inactive. Defaults to 1e-2. 0.01 Returns: Type Description BaseModel instance of BaseModel with the modifications applied. Source code in miom/miom.py @_autochain def subset_selection ( self , rxn_weights , eps = 1e-2 ): \"\"\"Transform the current model into a subset selection problem. The subset selection problem consists of selecting the positive weighted reactions and remove the negative weighted reactions, subject to steady state constraints and/or additional constraints on fluxes, and maximizing the weighted sum of the (absolute) weights for the successfully selected reactions (with positive weights) and the successfully removed reactions (with negative weights) Each reaction is associated with a weight (positive or negative) provided in the parameter `rxn_weights`, and the objective is to select the reactions that optimizes the following expression: $$ f(x) = \\sum_i^n |w_i| * x_i $$ where $x_i$ are the indicator variables for the reactions $i$ and $w_i$ are the weights for the reactions associated to the indicator variable. Indicator variables are automatically created for each reaction associated to a non-zero weight. Two (mutually exclusive) indicator variables are used for positive weighted reactions that are reversible to indicate whether there is positive or negative flux through the reaction. A single indicator variable is created for positive weighted non-reversible reactions, to indicate if the reaction is selected (has a non-zero flux) in which case the indicator variable is 1, or 0 otherwise. A single binary indicator variable is also created for negative weighted reactions, indicating whether the reaction was not selected (i.e, has 0 flux, in which case the indicator variable is 1) or not (in which case the indicator variable is 0). Args: rxn_weights (list): List of weights for each reaction. If a single value is provided, it is assumed to be the weight for all reactions. eps (float, optional): Min absolute flux value for weighted reactions to consider them active or inactive. Defaults to 1e-2. Returns: BaseModel: instance of BaseModel with the modifications applied. \"\"\" # Calculate min valid EPS based on integrality tolerance min_eps = self . _options [ \"_min_eps\" ] if eps < min_eps : warnings . warn ( f \"The minimum epsilon value is { min_eps } , which is less than { eps } .\" ) eps = max ( eps , min_eps ) if not isinstance ( rxn_weights , Iterable ): rxn_weights = [ rxn_weights ] * self . network . num_reactions rxnw = _weighted_rxns ( self . network . R , rxn_weights ) if self . variables . indicators is None : self . variables . _assigned_reactions = rxnw return dict ( eps = eps ) else : warnings . warn ( \"Indicator variables were already assigned\" ) return False","title":"subset_selection()"},{"location":"references/miom/#miom.miom.Comparator","text":"Comparator enum to use with select_subnetwork() Attributes: Name Type Description GREATER_OR_EQUAL str Select those variables with a value greater or equal than the one provided. LESS_OR_EQUAL str Select those variables with a value less or equal than the one provided.","title":"Comparator"},{"location":"references/miom/#miom.miom.ExtractionMode","text":"Method to select the subnetwork to be extracted. This mode works with the method select_subnetwork only after a subset selection problem was succesfully solved. If the model is configured as a subset selection problem, the user can extract a subnetwork after the method solve() was called. The selection of the subnetwork can be done using the indicator variables or the flux variables. For more information, please read the documentation of the method subset_selection Attributes: Name Type Description ABSOLUTE_FLUX_VALUE str Use a decision criterion based on the value of the fluxes. For example, by selecting all the reactions that have an absolute flux value above a certain threshold. INDICATOR_VALUE str Use the binary indicator variables to select the subnetwork. Binary indicator variables are created for a subset selection problem (after calling subset_selection ). Two indicators are created for each positive weighted and reversible reaction, to indicate if there is a non-zero positive flux or negative flux respectively. A single binary indicator variable is created for each negative weighted reaction. In this case, an indicator value of 1 indicates that the reaction was succesfully removed, and 0 otherwise. You can use the value of the indicator variables to select a subnetwork after solving. For example, if all the reactions have a negative weight (since the goal is, for example, to minimize the number of reactions subject to some other constraints) and you want to select only the reactions that were not removed after solving, you can use the indicator variables with a value of 0. Usage example: m . steady_state () . add_constraints ( ... ) . # Convert to a subset selection, where each reaction # has a weight of -1. subset_selection ( - 1 ) . # Solve the optimization problem . solve () # Get the subnetwork selecting the reactions # with an indicator value below 0.5. Since variables # are binary, it basically selects all the reactions # associated with a binary indicator value of 0. # This corresponds to the reactions that were not # removed after solving the problem (since all the # reactions have negative weights, and their binary # indicator variables are 1 if they were successfully # removed, and 0 if they could not be removed). . select_subnetwork ( mode = ExtractionMode . INDICATOR_VALUE , comparator = Comparator . LESS_OR_EQUAL , value = 0.5 ) . network","title":"ExtractionMode"},{"location":"references/miom/#miom.miom.Solvers","text":"Solvers supported by the miom module. Please refer to https://picos-api.gitlab.io/picos/introduction.html to see the list of supported solvers using the PICOS backend. The Python-MIP backend only supports the GUROBI and CBC solvers. Note that in some cases, the Python-MIP backend (GUROBI/CBC) might be faster setting up the problem than the PICOS backend since it has less overhead. Attributes: Name Type Description GUROBI_PYMIP str Recommended solver for most problems (LP, MIP). It uses the Python-MIP backend. Note that GUROBI is a commercial software which require a license. Free academic licenses are also available at https://gurobi.com/free/. GUROBI str For using GUROBI with the PICOS backend instead of Python-MIP. COIN_OR_CBC str Free LP/MIP solver with good performance, provided with Python-MIP. CPLEX str Commercial solver with a performance similar to GUROBI. Only supported by the PICOS backend. SCIP str Free academic solver, supported by the PICOS backend. GLPK str Open source solver, supported by the PICOS backend. MOSEK str Commercial solver, supported by the PICOS backend.","title":"Solvers"},{"location":"references/miom/#miom.miom.miom","text":"Create a MIOM optimization model for a given solver. If the solver is Coin-OR CBC, an instance of PythonMipModel is used (which uses the Python-MIP lib as the backend). Otherwise, a PicosModel is created (which uses PICOS as the backend). Examples: Example of how to perform FBA to maximize flux through the BIOMASS_reaction in the iMM1865 model: >>> from miom import miom , load_gem >>> network = load_gem ( \"https://github.com/pablormier/miom-gems/raw/main/gems/mus_musculus_iMM1865.miom\" ) >>> V , _ = miom ( network ) . steady_state () . set_rxn_objective ( \"BIOMASS_reaction\" ) . solve ( verbosity = 1 ) . get_values ()) Parameters: Name Type Description Default network miom_network A miom metabolic network. A metabolic network can be imported with the load_gem function. required solver Solver The solver to be used. Defaults to Solver.GLPK. <Solvers.COIN_OR_CBC: 'cbc'> Returns: Type Description BaseModel A BaseModel object, which can be PythonMipModel if CBC solver is used, or a PicosModel otherwise. Source code in miom/miom.py def miom ( network , solver = Solvers . COIN_OR_CBC ): \"\"\" Create a MIOM optimization model for a given solver. If the solver is Coin-OR CBC, an instance of PythonMipModel is used (which uses the Python-MIP lib as the backend). Otherwise, a PicosModel is created (which uses PICOS as the backend). Example: Example of how to perform FBA to maximize flux through the BIOMASS_reaction in the iMM1865 model: ```python >>> from miom import miom, load_gem >>> network = load_gem(\"https://github.com/pablormier/miom-gems/raw/main/gems/mus_musculus_iMM1865.miom\") >>> V, _ = miom(network) .steady_state() .set_rxn_objective(\"BIOMASS_reaction\") .solve(verbosity=1) .get_values()) ``` Args: network (miom_network): A miom metabolic network. A metabolic network can be imported with the [load_gem][miom.mio.load_gem] function. solver (Solver, optional): The solver to be used. Defaults to Solver.GLPK. Returns: BaseModel: A BaseModel object, which can be PythonMipModel if CBC solver is used, or a PicosModel otherwise. \"\"\" solver = str ( solver . value ) if isinstance ( solver , Enum ) else str ( solver ) if solver == 'cbc' : return PythonMipModel ( miom_network = network , solver_name = solver ) if solver == 'gurobi_pymip' : return PythonMipModel ( miom_network = network , solver_name = 'gurobi' ) else : return PicosModel ( miom_network = network , solver_name = solver )","title":"miom()"}]}